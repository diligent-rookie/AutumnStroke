<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>无标题文档</title>
<link rel="stylesheet" type="text/css" href="style.css"/>
</head>
<body>
<dl>
    <dt>css3、HTML5和移动端</dt>
    <dd>
        <p>移动端开发上手</p>
        <ol>
            <li>就像做网站的流程一样，如果你能知道它的流程，我相信就不会觉得做手机网站难！真正难的是你没有思路。</li>
            <li>好像觉得学会用html5+css3做手机网站，就相当于学会了顶尖的绝世武功。其实你错了！不要把html5想的太高深，其实做手机网站，真正意义上用不到太多的html5的强大功能。(可能对于一些不懂什么技术的小白而言：你的手机网站是用HTML5+CSS3做的啊，简直太牛了呀！能用上目前互联网上最新最前沿的技术。其实明眼人一看，就知道是用什么技术做的。俗话说的好："外行看热闹，内行看门道")</li>
            <li>基本上开发手机网站，可大致分为两大类。一类是用框架开发手机网站。一类是自己手写手机网站。</li>
            <li>框架开发手机网站(以bootstrap为例)<br/>
优点：<br/>
1.不懂设计也可以做网站<br/>
就算不懂设计，你的网页在Bootstrap的帮助下，也能拥有超高颜值。它拥有强大的内置样式库。主要体现在：字体文件和bootstrap自带的UI样式。（为广大不会UI设计的程序员，提供了福音）<br/>
2.上手快<br/>
你可以专心解决问题，冗繁的细节都丢给Bootstrap操心。可以做到一次开发，就可适配所有终端，并且能迅速上手并建出网站原型。还提供很多丰富的插件，就算你不会JS，基本能看懂常见的API，网站上的效果，基本能解决。<br/>
缺点：<br/>
1.不遵循最佳实践<br/>
我们在使用Bootstrap时遇到的最大问题之一是你的DOM元素上将拥挤大量的类。这打破了良好的web设计基本规则之一，HTML不再有语义，而且内容和表示不再分离。前端纯粹主义者会觉得这相当令人讨厌，以为它使可扩展性、重用性和维护性遇到了更大的挑战。<br/>
2. Bootstrap 太重<br/>
直接点说：就是CSS和JS有点点大。CSS压缩后115k,JS压缩后35k
如果你想要使用Bootstrap的所有功能，你应该好好考虑资源的加载时间。相信任何框架都有它的优点，同时也是有它的缺点的。没有一个产品是很完美的，所以根据自身实际情况进行选择。至于一些其它框架暂时不做过多的解释了，相信只要你肯愿意百度一下，就可以找到你想要的答案。
</li>
            <li>二、手写手机网站：<br/>
一般我们自己手动开发手机网站的话，基本可以划分两类来做到。一类是通过在网页头部添加meta标签进行实现（网页指html5的格式来开发）。另一类是通过CSS3的Media标签（媒介查询）来实现。
在这里我们详细讲解下,利用添加meta标签来做手机网站。
用swiper辅助手动开发手机网站（类似的库fullpage），头部：<pre>
    &lt;meta name="keywords" content="" /&gt;
    &lt;meta name="description" content="" /&gt; 
    &lt;!--描述和关键词--&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" /&gt;
    &lt;!--width  ----  viewport的宽度（width=device-width意思是：宽度等于设备宽度）
    initial-scale ----- 初始的缩放比例
    minimum-scale ----- 允许用户缩放到的最小比例
    maximum-scale ----- 允许用户缩放到的最大比例
    user-scalable ----- 用户是否可以手动缩放--&gt;
    &lt;meta name="format-detection" content="telephone=no" /&gt;
    &lt;!--一般情况下，IOS和Android系统都会默认某长度内的数字为电话号码，即使不加也是会默认显示为电话的，因此，取消这个很有必要！--&gt;
    &lt;meta name="apple-mobile-web-app-capable" content="yes" /&gt;
    &lt;!--它表示：允许全屏模式浏览，隐藏浏览器导航栏--&gt;
    &lt;meta name="apple-mobile-web-app-status-bar-style" content="black"&gt;
    &lt;!--它指定的iphone中safari顶端的状态条的样式
    默认值为default（白色），可以定为black（黑色）和black-translucent（灰色半透明）--&gt;</pre>js:<pre>
    window.onload = window.onresize = fontSelf;
    function fontSelf() {
        var wHtml = document.getElementById('html');
        var w = document.documentElement.clientWidth;
        w =  w > 768 ? 768 : document.documentElement.clientWidth;
        wHtml.style.fontSize = w * 0.045 + 'px';
    };</pre></li>
    		<li>最后：<br/>
其实等你真正熟悉做手机网站这套流程后，你会发现做手机网站没有你想象的那么难，真正难的是不知道如何去下手。对于移动端的JS效果可能和PC端有些不同，因为移动端有移动端的事件是原生JS，而不是Jquery。</li>
        </ol>
        <p>移动端js事件</p>
        <ol>
        	<li>touchstart   //手指刚接触屏幕时触发<br/>
touchmove    //手指在屏幕上移动时触发<br/>
touchend     //手指从屏幕上移开时触发<br/>
下面这个比较少用：<br/>
touchcancel  //触摸过程被系统取消时触发，例如正在玩游戏时有电话打入被强制弹出时</li>
            <li>每个事件都有以下列表，比如touchend的targetTouches当然是 0 了：<br/>
touches         //位于屏幕上的所有手指的列表<br/>
targetTouches   //位于该元素上的所有手指的列表<br/>
changedTouches  //涉及当前事件的所有手指的列表</li>
			<li>每个事件有列表，每个列表还有以下属性：<br/>
其中坐标常用pageX,pageY：<br/>
pageX    //相对于页面的 X 坐标<br/>
pageY    //相对于页面的 Y 坐标<br/>
clientX  //相对于视区的 X 坐标<br/>
clientY  //相对于视区的 Y 坐标<br/>
screenX  //相对于屏幕的 X 坐标<br/>
screenY  //相对于屏幕的 Y 坐标<br/>
identifier // 当前触摸点的惟一编号<br/>
target   //手指所触摸的 DOM 元素</li>
			<li>其他相关事件：<br/>
event.preventDefault（）   //阻止触摸时浏览器的缩放、滚动条滚动<br/>
var supportTouch = "createTouch" in document  //判断是否支持触摸事件</li>
			<li>以下是获取不同类型滑动的代码具体做法：<pre>
    #box{width:100%; height:500px; background-color:red;}
    &lt;div id="box"&gt;&lt;/div&gt;
    var oDiv = document.getElementById('box');
    touchFunc(oDiv,'left',function(){alert('左')})
    touchFunc(oDiv,'click',function(){alert('点击')})
    touchFunc(oDiv,'long',function(){alert('长按')})
    //三个参数，对象，事件，执行的函数
    function touchFunc(obj,type,func) {
        //滑动范围在5x5内则做点击处理，s是开始，e是结束
        var init = {x:5,y:5,sx:0,sy:0,ex:0,ey:0};
        var sTime = 0, eTime = 0;
        type = type.toLowerCase();
     
        obj.addEventListener("touchstart",function(){
            sTime = new Date().getTime();
            init.sx = event.targetTouches[0].pageX;
            init.sy = event.targetTouches[0].pageY;
            init.ex = init.sx;
            init.ey = init.sy;
            if(type.indexOf("start") != -1) func();
        }, false);
     
        obj.addEventListener("touchmove",function() {
            event.preventDefault();//阻止触摸时浏览器的缩放、滚动条滚动
            init.ex = event.targetTouches[0].pageX;
            init.ey = event.targetTouches[0].pageY;
            if(type.indexOf("move")!=-1) func();
        }, false);
     
        obj.addEventListener("touchend",function() {
            var changeX = init.sx - init.ex;
            var changeY = init.sy - init.ey;
            if(Math.abs(changeX)>Math.abs(changeY)&&Math.abs(changeY)>init.y) {
                //左右事件
                if(changeX > 0) {
                    if(type.indexOf("left")!=-1) func();
                }else{
                    if(type.indexOf("right")!=-1) func();
                }
            }
            else if(Math.abs(changeY)>Math.abs(changeX)&&Math.abs(changeX)>init.x){
                //上下事件
                if(changeY > 0) {
                    if(type.indexOf("top")!=-1) func();
                }else{
                    if(type.indexOf("down")!=-1) func();
                }
            }
            else if(Math.abs(changeX)<init.x && Math.abs(changeY)<init.y){
                eTime = new Date().getTime();
                //点击事件，此处根据时间差细分下
                if((eTime - sTime) > 300) {
                    if(type.indexOf("long")!=-1) func(); //长按
                }
                else {
                    if(type.indexOf("click")!=-1) func(); //当点击处理
                }
            }
            if(type.indexOf("end")!=-1) func();
        }, false);
    };</pre></li>
        </ol>
    </dd>
</dl>
</body>
</html>
